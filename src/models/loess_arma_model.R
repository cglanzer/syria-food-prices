# ################################################################################################################################
# loess_arma_model.R
# This model first estimates the trend with LOESS (Local Polynomial Regression Fitting) and a fixed smoothing parameter,
# then fits a ARMA model to the remainder if possible, using auto.arima().
# This is the model file allowing for custom predictions.
# ################################################################################################################################

# DETAILED MODEL DESCRIPTION
# Let time_series be an arbitrary subdistrict / district / governorate / price for a product in a district / subdistrict / governorate.
# We fit loess() to log(time_series). Then, we calculate the remainder (what was not explained by our fitted trend) and
# search for a dependency structure (Autocorrelation, Partial autocorrelation). If there is a dependency structure,
# we fit an ARMA model (Autoregression / Moving Average model) using auto.arima(). This automatically determines the best hyperparameters of this model.
# Note: There appears to be a bug in R, which is why we fit the auto.arima() model including an intercept term.

# PARAMETERS / HOW TO USE
# Parameter: input_file:
# Please, create a .csv file in the same format as 'testing_data.csv' (which is generated by the data cleaning script):
# Row one first contains in its first entry the term 'months' and then the names of the districts.
# For the remaining rows:
# The entries of the first column are the months. They are not read by this file and can be of any format.
# The entries of the second to last column are the SMEB values / prices of products as float numbers.
# Example, where we want to forecast the SMEB for two districts and where we know that the first district
# as SMEB values 154, 156, 201, 106, 115 and the second district has values 112, 118, 121, 126, 155
# both for months 2018-08 to 2018-12:
# months  SY100101  SY200012
# 2018-08 154       112
# 2018-09 156       118
# 2018-10 201       121
# 2018-11 106       126
# 2018-12 115       155

# Parameter forecast_length: Specify the forecast length in months.
# Note: If you forecast several time series with plots, press ENTER to shift between the plots!
# Note: If you forecast for 3 months, the result for the next month is the same as if you forecast for just 1 month.

# Parameter show_plots: Set to true to plot results for each series.

# RETURNS: Returns a data.frame with the predictions of the model.

# Package 'forecast': For auto.arima()
if (!require("forecast")) { install.packages("forecast"); }
library("forecast")

print("Loess-Arma Model (forecast_arma_loess()).")
print("Please read the source file for more information on how to use.")

# Note: Sometimes, R reports that an ARMA model was fitted although its coefficients are zero.
# To determine whether this is the case (if necessary), please print(ts.log.fit.arima) manually.

forecast_arma_loess = function(input_file = "../../data/processed/testing_data.csv", forecast_length = 3, show_plots = TRUE) {
  
  # Load the data
  # Note: The hyperparameters (mainly just the degree of the smoother) were chosen from the district training data.
  data = read.csv(input_file, header=TRUE)
  data = data[,-1] # Remove the 'months' column
  
  forecast_results = matrix(rep(0,dim(data)[2] * forecast_length), ncol=dim(data)[2]) # Stores the results of each district / time series in one column
  
  for (col_ind in 1:dim(data)[2]) { # Iterate over all columns of data we received.
    
    series_name = labels(data)[[2]][col_ind]
    dat = data[,col_ind]
    
    if (sum(is.na(dat)) > 1) {
      print(paste("Warning: For series", series_name, "there are NA values! They were interpolated linearly."))
      dat = na.interpolation(dat, option="linear")
    }
    
    ts.orig = ts(dat)
    ts.log.orig = ts(log(dat)) # We perform a log-transformation
    
    training.window = 1:length(dat)
    forecast.window = 1:forecast_length + length(dat)
    
    ts.training = ts(dat[training.window])
    ts.log.training = ts(log(dat[training.window])) # log of the training data for the current time series.
    
    # Fit trend and calculate remainder
    # We fit a degree 1 trend with loess.
    loesstmp <- loess(ts.log.training~time(ts.log.training), degree = 1, span = 1, control=loess.control(surface="direct"))
    ts.log.fit.trend <- loesstmp$fitted
    ts.log.fit.trend.remainder <- loesstmp$residuals
    
    # Fit ARMA(p,q) via auto-fit to the remainder.
    ts.log.fit.arima = tryCatch({
      auto.arima(ts(ts.log.fit.trend.remainder), max.p = 12, max.q = 12, stationary = TRUE, ic = "aic", stepwise=FALSE)
    },
    error = function(err) {
      #print("No ARMA model estimated. Remainder has insignificant acf / pacf (auto.arima()).")
      return(FALSE)
    })
    with_arma=TRUE
    if (class(ts.log.fit.arima)[1] == "logical") { with_arma=FALSE } # It's FALSE if there's no suitable auto.arima() fit. This means that there was no sufficient dependency structure detected.
    
    # Calculate predictions, case by case analysis whether we have fitted an ARMA model or not. If not, we use only the trend estimate.
    ts.log.predict.trend = predict(loesstmp, newdata=forecast.window)
    if (with_arma) { ts.log.predict.arima <- predict(ts.log.fit.arima, n.ahead=length(forecast.window))$pred }
    if (with_arma) { ts.log.predict.total = ts.log.predict.trend + ts.log.predict.arima }
    if (!with_arma) { ts.log.predict.total = ts.log.predict.trend }
    
    if (!with_arma & show_plots) {
      print(paste(series_name, ": Only a trend was fitted as there was no sufficient structure detected to fit an ARMA(p,q) and a trend.", sep=""))
    }
    
    # Exponentiate final prediction
    ts.predict.total = exp(ts.log.predict.total)
    
    # Calculate baseline model prediction, just repeating the last observed value.
    # We plot this for comparison.
    bslin_predict = rep(ts.orig[training.window[length(training.window)]], rep(length(forecast.window)))
    
    # Exponentiate to predict original data / model.
    if (show_plots) {
      plot(ts.orig, type="o", xlab="Time in months", ylab="Price", xlim = c(0, length(ts.orig)+forecast_length), ylim=c(min(c(min(ts.orig), min(ts.predict.total))) - 10, max(c(max(ts.orig), max(ts.predict.total))) + 10))
      title(paste("Prediction for series", series_name, "with loess() + ARMA(p,q)."))
      lines(training.window, exp(predict(loesstmp, newdata=training.window)), type="o", col="blue")
      lines(forecast.window, ts.predict.total, col="red", type="o")
      lines(forecast.window, bslin_predict, col="orange", type="o")
      if (with_arma) { legend("topleft", bg="white", legend=c("Original data", "Trend in training data", "Model Prediction", "Baseline model"), lty=c(1,1,1,1), col=c("black", "blue", "red","orange")) }
      if (!with_arma) { legend("topleft", bg="white", legend=c("Original data", "Trend in training data", "Model Prediction", "Baseline model"), lty=c(1,1,1,1), col=c("black", "blue", "red","orange")) }
      readline(prompt="Press [Enter] to continue.")
    }
    
    forecast_results[,col_ind] = ts.predict.total
  }
  
  ret = as.data.frame(forecast_results)
  names(ret) <- names(data)
  return(ret)
}


